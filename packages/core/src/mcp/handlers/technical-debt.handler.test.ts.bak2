import { describe, it, expect, vi, beforeEach } from 'vitest';
import { handleGetTechnicalDebt } from './technical-debt.handler';

// Mock all dependencies
vi.mock('../../core/analysis/index.js');
vi.mock('../../universal/project-manager');
vi.mock('../../shared/validators/mcp-schemas');

describe('handleGetTechnicalDebt', () => {
  let mockQualityAnalyzer: any;
  let mockProjectManager: any;
  let mockValidateInput: any;

  beforeEach(async () => {
    // Mock validateInput
    const validators = await import('../../shared/validators/mcp-schemas');
    mockValidateInput = vi.mocked(validators.validateInput);
    mockValidateInput.mockReturnValue({
      includeBudgetAnalysis: true
    });

    // Mock ProjectManager
    const projectManagerModule = await import('../../universal/project-manager');
    mockProjectManager = {};
    vi.mocked(projectManagerModule.ProjectManager).mockImplementation(() => mockProjectManager);

    // Mock QualityAnalyzer
    const analysisModule = await import('../../core/analysis/index.js');
    mockQualityAnalyzer = {
      getTechnicalDebt: vi.fn(async () =>
        'TECHNICAL DEBT ANALYSIS\n\nTotal Debt: 5h 30m\nDebt Ratio: 2.5%'
      )
    };
    vi.mocked(analysisModule.QualityAnalyzer).mockImplementation(() => mockQualityAnalyzer);
  });

  describe('Success cases', () => {
    it('should validate input and call QualityAnalyzer', async () => {
      const args = {
        includeBudgetAnalysis: true
      };

      const result = await handleGetTechnicalDebt(args);

      expect(mockValidateInput).toHaveBeenCalledWith(
        expect.anything(),
        args,
        'sonar_get_technical_debt'
      );
      expect(mockQualityAnalyzer.getTechnicalDebt).toHaveBeenCalledWith(
        {
          includeBudgetAnalysis: true
        },
        undefined
      );
      expect(result).toHaveProperty('content');
      expect(result.content[0].type).toBe('text');
    });

    it('should pass correlation ID through', async () => {
      const correlationId = 'test-corr-123';
      await handleGetTechnicalDebt({}, correlationId);

      expect(mockQualityAnalyzer.getTechnicalDebt).toHaveBeenCalledWith(
        expect.anything(),
        correlationId
      );
    });

    it('should return technical debt report', async () => {
      const result = await handleGetTechnicalDebt({});

      expect(result.content[0].text).toContain('TECHNICAL DEBT ANALYSIS');
      expect(result.content[0].text).toContain('Total Debt');
    });

    it('should handle includeBudgetAnalysis true', async () => {
      mockValidateInput.mockReturnValue({
        includeBudgetAnalysis: true
      });

      await handleGetTechnicalDebt({});

      expect(mockQualityAnalyzer.getTechnicalDebt).toHaveBeenCalledWith(
        expect.objectContaining({
          includeBudgetAnalysis: true
        }),
        undefined
      );
    });

    it('should handle includeBudgetAnalysis false', async () => {
      mockValidateInput.mockReturnValue({
        includeBudgetAnalysis: false
      });

      await handleGetTechnicalDebt({});

      expect(mockQualityAnalyzer.getTechnicalDebt).toHaveBeenCalledWith(
        expect.objectContaining({
          includeBudgetAnalysis: false
        }),
        undefined
      );
    });

    it('should format technical debt data correctly', async () => {
      mockQualityAnalyzer.getTechnicalDebt = vi.fn(async () =>
        'TECHNICAL DEBT ANALYSIS\n\nTotal Debt: 10h\nDebt Ratio: 5%\nBudget Status: Within limits'
      );

      const result = await handleGetTechnicalDebt({});

      expect(result.content[0].text).toContain('Budget Status');
    });

    it('should work with empty args', async () => {
      const result = await handleGetTechnicalDebt({});

      expect(mockQualityAnalyzer.getTechnicalDebt).toHaveBeenCalled();
      expect(result).toHaveProperty('content');
    });
  });

  describe('Error handling', () => {
    it('should handle validation errors gracefully', async () => {
      mockValidateInput.mockImplementation(() => {
        throw new Error('Invalid parameter');
      });

      const result = await handleGetTechnicalDebt({});

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Error getting technical debt analysis');
      expect(result.content[0].text).toContain('Invalid parameter');
    });

    it('should handle analyzer errors gracefully', async () => {
      mockQualityAnalyzer.getTechnicalDebt = vi.fn(async () => {
        throw new Error('Failed to fetch technical debt');
      });

      const result = await handleGetTechnicalDebt({});

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Error getting technical debt analysis');
      expect(result.content[0].text).toContain('Failed to fetch technical debt');
    });

    it('should handle errors without message', async () => {
      mockQualityAnalyzer.getTechnicalDebt = vi.fn(async () => {
        throw {};
      });

      const result = await handleGetTechnicalDebt({});

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Error getting technical debt analysis');
    });

    it('should handle API errors', async () => {
      mockQualityAnalyzer.getTechnicalDebt = vi.fn(async () => {
        throw new Error('SonarQube API error');
      });

      const result = await handleGetTechnicalDebt({});

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('SonarQube API error');
    });

    it('should return error response instead of throwing', async () => {
      mockValidateInput.mockImplementation(() => {
        throw new Error('Validation failed');
      });

      // Should not throw, should return error response
      const result = await handleGetTechnicalDebt({});
      expect(result.isError).toBe(true);
    });
  });
});
