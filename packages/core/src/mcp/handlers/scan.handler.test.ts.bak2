import { describe, it, expect, vi, beforeEach } from 'vitest';
import { handleScanProject } from './scan.handler';

// Mock all dependencies
vi.mock('../../core/scanning/index.js');
vi.mock('../../universal/project-manager');
vi.mock('../../universal/sonar-admin');
vi.mock('../../shared/validators/mcp-schemas');
vi.mock('../../infrastructure/security/input-sanitization');

describe('handleScanProject', () => {
  let mockScanOrchestrator: any;
  let mockValidateInput: any;
  let mockSanitizeUrl: any;

  beforeEach(async () => {
    // Mock validateInput
    const validators = await import('../../shared/validators/mcp-schemas');
    mockValidateInput = vi.mocked(validators.validateInput);
    mockValidateInput.mockReturnValue({
      projectPath: '/test/project',
      severityFilter: ['CRITICAL'],
      typeFilter: ['BUG'],
      autoSetup: false,
    });

    // Mock sanitizeUrl
    const security = await import('../../infrastructure/security/input-sanitization');
    mockSanitizeUrl = vi.mocked(security.sanitizeUrl);
    mockSanitizeUrl = vi.fn(() => 'http://localhost:9000');

    // Mock ScanOrchestrator
    const scanning = await import('../../core/scanning/index.js');
    mockScanOrchestrator = {
      execute: vi.fn(async () => ({
        projectKey: 'test-project',
        totalIssues: 5,
        issuesBySeverity: { CRITICAL: 2, MAJOR: 3 },
        qualityScore: 75,
        topIssues: [],
        projectContext: {
          path: '/test/project',
          name: 'test-project',
          language: ['typescript'],
        },
      })),
    };
    vi.mocked(scanning.ScanOrchestrator).mockImplementation(() => mockScanOrchestrator);

    // Mock ScanResultProcessor
    vi.mocked(scanning.ScanResultProcessor.formatAsTextSummary).mockReturnValue(
      'SONARQUBE ANALYSIS RESULTS\n\nProject: test-project\nTotal Issues: 5'
    );

    // Set environment variables
    process.env.SONAR_URL = 'http://localhost:9000';
    process.env.SONAR_TOKEN = 'test-token';
  });

  describe('Success cases', () => {
    it('should validate input and call ScanOrchestrator', async () => {
      const args = {
        projectPath: '/test/project',
        severityFilter: ['CRITICAL'],
        autoSetup: false,
      };

      const result = await handleScanProject(args);

      expect(mockValidateInput).toHaveBeenCalledWith(
        expect.anything(),
        args,
        'sonar_scan_project'
      );
      expect(mockScanOrchestrator.execute).toHaveBeenCalledWith(
        expect.objectContaining({
          projectPath: '/test/project',
          severityFilter: ['CRITICAL'],
          autoSetup: false,
        }),
        undefined
      );
      expect(result).toHaveProperty('content');
      expect(result.content[0].type).toBe('text');
    });

    it('should pass correlation ID through', async () => {
      const correlationId = 'test-corr-123';
      await handleScanProject({}, correlationId);

      expect(mockScanOrchestrator.execute).toHaveBeenCalledWith(
        expect.anything(),
        correlationId
      );
    });

    it('should format result as text summary', async () => {
      const result = await handleScanProject({});

      expect(result.content[0].text).toContain('SONARQUBE ANALYSIS RESULTS');
      expect(result.content[0].text).toContain('test-project');
    });

    it('should sanitize SONAR_URL from environment', async () => {
      await handleScanProject({});

      expect(mockSanitizeUrl).toHaveBeenCalledWith('http://localhost:9000');
    });

    it('should use default SONAR_URL when not set', async () => {
      delete process.env.SONAR_URL;
      await handleScanProject({});

      expect(mockSanitizeUrl).toHaveBeenCalledWith('http://localhost:9000');
    });
  });

  describe('Error handling', () => {
    it('should propagate validation errors', async () => {
      mockValidateInput.mockImplementation(() => {
        throw new Error('Validation failed');
      });

      await expect(handleScanProject({})).rejects.toThrow('Validation failed');
    });

    it('should propagate orchestrator errors', async () => {
      mockScanOrchestrator.execute = vi.fn(async () => {
        throw new Error('Scan failed');
      });

      await expect(handleScanProject({})).rejects.toThrow('Scan failed');
    });
  });

  describe('Parameter handling', () => {
    it('should handle all severity filters', async () => {
      mockValidateInput.mockReturnValue({
        severityFilter: ['BLOCKER', 'CRITICAL', 'MAJOR'],
      });

      await handleScanProject({});

      expect(mockScanOrchestrator.execute).toHaveBeenCalledWith(
        expect.objectContaining({
          severityFilter: ['BLOCKER', 'CRITICAL', 'MAJOR'],
        }),
        undefined
      );
    });

    it('should handle all type filters', async () => {
      mockValidateInput.mockReturnValue({
        typeFilter: ['BUG', 'VULNERABILITY', 'CODE_SMELL'],
      });

      await handleScanProject({});

      expect(mockScanOrchestrator.execute).toHaveBeenCalledWith(
        expect.objectContaining({
          typeFilter: ['BUG', 'VULNERABILITY', 'CODE_SMELL'],
        }),
        undefined
      );
    });

    it('should handle autoSetup true', async () => {
      mockValidateInput.mockReturnValue({
        autoSetup: true,
      });

      await handleScanProject({});

      expect(mockScanOrchestrator.execute).toHaveBeenCalledWith(
        expect.objectContaining({
          autoSetup: true,
        }),
        undefined
      );
    });
  });
});
