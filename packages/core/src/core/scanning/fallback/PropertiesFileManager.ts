/**
 * PropertiesFileManager
 * Manages sonar-project.properties file creation, backup, and validation
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { SonarPropertiesConfig, GenerateConfigResult } from '../../../shared/types/index.js';

export class PropertiesFileManager {
  private readonly fileName = 'sonar-project.properties';

  /**
   * Generate and write sonar-project.properties file
   */
  async writeConfig(
    projectPath: string,
    config: SonarPropertiesConfig
  ): Promise<GenerateConfigResult> {
    const configPath = path.join(projectPath, this.fileName);
    const warnings: string[] = [];

    // Check for existing file and backup
    let backupPath: string | undefined;
    try {
      await fs.access(configPath);
      backupPath = await this.createBackup(configPath);
    } catch {
      // File doesn't exist, no backup needed
    }

    // Generate content
    const content = this.generateContent(config);

    // Validate content
    const validationErrors = this.validateContent(content);
    if (validationErrors.length > 0) {
      warnings.push(...validationErrors);
    }

    // Write file
    await fs.writeFile(configPath, content, 'utf-8');

    // Add to .gitignore if not already
    await this.ensureGitignore(projectPath);

    return {
      success: true,
      configPath,
      backupPath,
      generatedContent: content,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }

  /**
   * Generate properties file content
   */
  private generateContent(config: SonarPropertiesConfig): string {
    const lines: string[] = [
      '# SonarQube Project Configuration',
      `# Generated by Bob the Fixer at ${new Date().toISOString()}`,
      ''
    ];

    // Project identification
    lines.push('# Project identification');
    lines.push(`sonar.projectKey=${config.projectKey}`);

    if (config.projectName) {
      lines.push(`sonar.projectName=${config.projectName}`);
    }

    if (config.projectVersion) {
      lines.push(`sonar.projectVersion=${config.projectVersion}`);
    }

    lines.push('');

    // Multi-module configuration
    if (config.modules && config.modules.length > 0) {
      lines.push('# Multi-module project configuration');
      lines.push(`sonar.modules=${config.modules.map(m => m.name).join(',')}`);
      lines.push('');

      // Per-module configuration
      for (const module of config.modules) {
        lines.push(`# Module: ${module.name}`);
        lines.push(`${module.name}.sonar.projectBaseDir=${module.baseDir}`);
        lines.push(`${module.name}.sonar.sources=${module.sources}`);

        if (module.tests) {
          lines.push(`${module.name}.sonar.tests=${module.tests}`);
        }

        if (module.binaries) {
          lines.push(`${module.name}.sonar.java.binaries=${module.binaries}`);
        }

        if (module.exclusions) {
          lines.push(`${module.name}.sonar.exclusions=${module.exclusions}`);
        }

        if (module.language) {
          lines.push(`${module.name}.sonar.language=${module.language}`);
        }

        lines.push('');
      }
    } else {
      // Single module configuration
      lines.push('# Source configuration');
      lines.push(`sonar.sources=${config.sources}`);

      if (config.tests) {
        lines.push(`sonar.tests=${config.tests}`);
      }

      lines.push('');

      // Java-specific
      if (config.javaBinaries || config.javaSource) {
        lines.push('# Java configuration');

        if (config.javaBinaries) {
          lines.push(`sonar.java.binaries=${config.javaBinaries}`);
        }

        if (config.javaTestBinaries) {
          lines.push(`sonar.java.test.binaries=${config.javaTestBinaries}`);
        }

        if (config.javaLibraries) {
          lines.push(`sonar.java.libraries=${config.javaLibraries}`);
        }

        if (config.javaSource) {
          lines.push(`sonar.java.source=${config.javaSource}`);
        }

        lines.push('');
      }
    }

    // Exclusions
    if (config.exclusions) {
      lines.push('# Exclusions');
      lines.push(`sonar.exclusions=${config.exclusions}`);
      lines.push('');
    }

    // Encoding
    if (config.encoding) {
      lines.push('# Encoding');
      lines.push(`sonar.sourceEncoding=${config.encoding}`);
      lines.push('');
    }

    // Coverage
    if (config.coverageReportPaths) {
      lines.push('# Coverage reports');
      lines.push(`sonar.coverage.jacoco.xmlReportPaths=${config.coverageReportPaths}`);
      lines.push('');
    }

    // Additional properties
    if (config.additionalProperties) {
      lines.push('# Additional properties');
      for (const [key, value] of Object.entries(config.additionalProperties)) {
        lines.push(`${key}=${value}`);
      }
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Create backup of existing file
   */
  private async createBackup(filePath: string): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = `${filePath}.backup.${timestamp}`;
    await fs.copyFile(filePath, backupPath);
    return backupPath;
  }

  /**
   * Validate properties file content
   */
  private validateContent(content: string): string[] {
    const warnings: string[] = [];
    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Skip comments and empty lines
      if (line.startsWith('#') || line === '') continue;

      // Check for valid property format
      if (!line.includes('=')) {
        warnings.push(`Line ${i + 1}: Invalid property format (missing '=')`);
        continue;
      }

      const [key] = line.split('=', 2);

      // Check for empty key
      if (!key || key.trim() === '') {
        warnings.push(`Line ${i + 1}: Empty property key`);
      }

      // Check for invalid characters in key
      if (!/^[a-zA-Z0-9._-]+$/.test(key.trim())) {
        warnings.push(`Line ${i + 1}: Invalid characters in property key '${key}'`);
      }
    }

    return warnings;
  }

  /**
   * Ensure sonar-project.properties is in .gitignore
   */
  private async ensureGitignore(projectPath: string): Promise<void> {
    const gitignorePath = path.join(projectPath, '.gitignore');

    try {
      let content: string;

      try {
        content = await fs.readFile(gitignorePath, 'utf-8');
      } catch {
        // .gitignore doesn't exist, create it
        content = '';
      }

      // Check if already in .gitignore
      if (!content.includes(this.fileName)) {
        const addition = content.endsWith('\n') || content === ''
          ? `# SonarQube local configuration\n${this.fileName}\n`
          : `\n# SonarQube local configuration\n${this.fileName}\n`;

        await fs.appendFile(gitignorePath, addition);
      }
    } catch {
      // Ignore errors with .gitignore
    }
  }

  /**
   * Check if properties file exists
   */
  async exists(projectPath: string): Promise<boolean> {
    try {
      await fs.access(path.join(projectPath, this.fileName));
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Read existing properties file
   */
  async read(projectPath: string): Promise<Record<string, string> | null> {
    try {
      const content = await fs.readFile(
        path.join(projectPath, this.fileName),
        'utf-8'
      );
      return this.parseProperties(content);
    } catch {
      return null;
    }
  }

  /**
   * Parse properties file content
   */
  private parseProperties(content: string): Record<string, string> {
    const props: Record<string, string> = {};
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.startsWith('#') || trimmed === '') continue;

      const eqIndex = trimmed.indexOf('=');
      if (eqIndex > 0) {
        const key = trimmed.substring(0, eqIndex).trim();
        const value = trimmed.substring(eqIndex + 1).trim();
        props[key] = value;
      }
    }

    return props;
  }

  /**
   * Delete properties file
   */
  async delete(projectPath: string): Promise<void> {
    try {
      await fs.unlink(path.join(projectPath, this.fileName));
    } catch {
      // File might not exist
    }
  }
}
