import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ScanOrchestrator } from './ScanOrchestrator';
import { mockIssue } from '../../../tests/fixtures/mock-sonar-responses';

// Create mock instances at module level
const mockProjectManager = {
  setWorkingDirectory: vi.fn(() => {}),
  getWorkingDirectory: vi.fn(() => '/test/project'),
  analyzeProject: vi.fn(() => Promise.resolve()),
  getOrCreateConfig: vi.fn(() => Promise.resolve()),
};

const mockSonarAdmin = {
  createProject: vi.fn(() => Promise.resolve()),
  generateToken: vi.fn(() => Promise.resolve()),
};

const mockSonarClient = {
  triggerAnalysis: vi.fn(() => Promise.resolve()),
  waitForAnalysis: vi.fn(() => Promise.resolve()),
  getIssues: vi.fn(() => Promise.resolve([])),
};

const mockProjectContext = {
  path: '/test/project',
  name: 'test-project',
  languages: ['typescript'],
  frameworks: ['node'],
  testFrameworks: [],
  buildTools: ['npm'],
  hasTests: false,
  configFiles: [],
};

const mockConfig = {
  sonarProjectKey: 'test-project',
  sonarUrl: 'http://localhost:9000',
  sonarToken: 'sqp_test_token_1234567890',
  createdAt: '2024-01-01T00:00:00.000Z',
};

// Mock modules
vi.mock('../../universal/project-manager', () => ({
  ProjectManager: vi.fn(() => mockProjectManager),
}));

vi.mock('../../universal/sonar-admin', () => ({
  SonarAdmin: vi.fn(() => mockSonarAdmin),
}));

vi.mock('../../sonar/client', () => ({
  SonarQubeClient: vi.fn(() => mockSonarClient),
}));

vi.mock('../../sonar/index', () => ({
  SonarQubeClient: vi.fn(() => mockSonarClient),
  verifyProjectSetup: vi.fn().mockResolvedValue(undefined),
  waitForCacheRefresh: vi.fn().mockResolvedValue(undefined),
}));

vi.mock('fs/promises', () => ({
  default: {
    access: vi.fn().mockRejectedValue(new Error('File not found')),
  },
  access: vi.fn().mockRejectedValue(new Error('File not found')),
}));

vi.mock('../../shared/utils/server-utils', () => ({
  generateProjectKey: vi.fn(() => 'test-project'),
  saveConfigToFile: vi.fn().mockResolvedValue(undefined),
  calculateQualityScore: vi.fn(() => 85),
  getSeverityWeight: vi.fn((severity: string) => {
    const weights: Record<string, number> = {
      BLOCKER: 5, CRITICAL: 4, MAJOR: 3, MINOR: 2, INFO: 1,
    };
    return weights[severity] || 0;
  }),
}));

vi.mock('../../shared/logger/structured-logger', () => ({
  getLogger: vi.fn(() => ({
    info: vi.fn(() => {}),
    debug: vi.fn(() => {}),
    warn: vi.fn(() => {}),
    error: vi.fn(() => {}),
  })),
}));

vi.mock('../../infrastructure/security/input-sanitization', () => ({
  sanitizePath: vi.fn((path: string) => path),
  sanitizeLogMessage: vi.fn((msg: string) => msg),
  sanitizeCommandArgs: vi.fn((args: string[]) => args),
  shellQuote: vi.fn((str: string) => `'${str}'`),
  sanitizeProjectKey: vi.fn((key: string) => key),
  sanitizeUrl: vi.fn((url: string) => url),
  maskToken: vi.fn((token: string) => token.substring(0, 10) + '...'),
}));

describe('ScanOrchestrator', () => {
  let orchestrator: ScanOrchestrator;

  beforeEach(() => {
    // Reset function call history but keep implementations
    vi.mocked(mockProjectManager.setWorkingDirectory).mockClear();
    vi.mocked(mockProjectManager.getWorkingDirectory).mockClear();
    vi.mocked(mockProjectManager.analyzeProject).mockClear();
    vi.mocked(mockProjectManager.getOrCreateConfig).mockClear();
    vi.mocked(mockSonarAdmin.createProject).mockClear();
    vi.mocked(mockSonarAdmin.generateToken).mockClear();
    vi.mocked(mockSonarClient.triggerAnalysis).mockClear();
    vi.mocked(mockSonarClient.waitForAnalysis).mockClear();
    vi.mocked(mockSonarClient.getIssues).mockClear();

    // Set default return values
    mockProjectManager.analyzeProject = vi.fn(async () => mockProjectContext);
    mockProjectManager.getOrCreateConfig = vi.fn(async () => mockConfig);
    mockSonarClient.triggerAnalysis = vi.fn(async () => undefined);
    mockSonarClient.waitForAnalysis = vi.fn(async () => undefined);
    mockSonarClient.getIssues = vi.fn(async () => [mockIssue]);
    mockSonarAdmin.createProject = vi.fn(async () => undefined);
    mockSonarAdmin.generateToken.mockResolvedValue({
      name: 'test-token',
      token: 'sqp_generated_token',
      createdAt: '2024-01-01T00:00:00.000Z',
    });

    orchestrator = new ScanOrchestrator(mockProjectManager, mockSonarAdmin);
  });

  describe('Constructor', () => {
    it('should create orchestrator with default options', () => {
      const orch = new ScanOrchestrator(mockProjectManager, mockSonarAdmin);
      expect(orch).toBeDefined();
    });

    it('should accept custom options', () => {
      const orch = new ScanOrchestrator(mockProjectManager, mockSonarAdmin, {
        maxRetries: 5,
        retryDelay: 10000,
      });
      expect(orch).toBeDefined();
    });
  });

  describe('execute - success path', () => {
    it('should execute complete scan workflow successfully', async () => {
      const result = await orchestrator.execute({ autoSetup: false });

      expect(result).toBeDefined();
      expect(result.projectKey).toBe('test-project');
      expect(result.totalIssues).toBe(1);
      expect(result.qualityScore).toBe(85);
      expect(mockSonarClient.triggerAnalysis).toHaveBeenCalled();
      expect(mockSonarClient.waitForAnalysis).toHaveBeenCalled();
      expect(mockSonarClient.getIssues).toHaveBeenCalled();
    });

    it('should handle multiple issues and sort by severity', async () => {
      mockSonarClient.getIssues.mockResolvedValue([
        { ...mockIssue, key: 'issue-1', severity: 'MINOR' },
        { ...mockIssue, key: 'issue-2', severity: 'CRITICAL' },
        { ...mockIssue, key: 'issue-3', severity: 'BLOCKER' },
      ]);

      const result = await orchestrator.execute({ autoSetup: false });

      expect(result.totalIssues).toBe(3);
      expect(result.topIssues[0].severity).toBe('BLOCKER');
      expect(result.topIssues[1].severity).toBe('CRITICAL');
    });

    it('should apply severity filters', async () => {
      await orchestrator.execute({
        autoSetup: false,
        severityFilter: ['CRITICAL', 'BLOCKER'],
      });

      expect(mockSonarClient.getIssues).toHaveBeenCalledWith(
        expect.objectContaining({
          severities: ['CRITICAL', 'BLOCKER'],
        })
      );
    });

    it('should apply type filters', async () => {
      await orchestrator.execute({
        autoSetup: false,
        typeFilter: ['BUG', 'VULNERABILITY'],
      });

      expect(mockSonarClient.getIssues).toHaveBeenCalledWith(
        expect.objectContaining({
          types: ['BUG', 'VULNERABILITY'],
        })
      );
    });

    it('should handle empty issues array', async () => {
      mockSonarClient.getIssues = vi.fn(async () => []);

      const result = await orchestrator.execute({ autoSetup: false });

      expect(result.totalIssues).toBe(0);
      expect(result.topIssues).toEqual([]);
    });
  });

  describe('execute - auto-setup', () => {
    it('should perform auto-setup when config not found', async () => {
      mockProjectManager.getOrCreateConfig
        .mockRejectedValueOnce(new Error('Config not found'))
        .mockResolvedValueOnce(mockConfig);

      await orchestrator.execute({ autoSetup: true });

      expect(mockSonarAdmin.createProject).toHaveBeenCalled();
      expect(mockSonarAdmin.generateToken).toHaveBeenCalled();
    });

    it('should throw error when autoSetup is false and config not found', async () => {
      mockProjectManager.getOrCreateConfig.mockRejectedValue(
        new Error('Config not found')
      );

      await expect(
        orchestrator.execute({ autoSetup: false })
      ).rejects.toThrow('No Bob the Fixer configuration found');
    });
  });

  describe('execute - error handling', () => {
    it('should handle project manager errors', async () => {
      mockProjectManager.analyzeProject.mockRejectedValue(
        new Error('Analysis failed')
      );

      await expect(
        orchestrator.execute({ autoSetup: false })
      ).rejects.toThrow('Analysis failed');
    });

    it('should handle sonar client errors', async () => {
      mockSonarClient.triggerAnalysis.mockRejectedValue(
        new Error('Analysis failed')
      );

      await expect(
        orchestrator.execute({ autoSetup: false })
      ).rejects.toThrow();
    });

    it('should handle issue fetching errors', async () => {
      mockSonarClient.getIssues = vi.fn(async () => { throw new Error('API error'); });

      await expect(
        orchestrator.execute({ autoSetup: false })
      ).rejects.toThrow('API error');
    });
  });
});
